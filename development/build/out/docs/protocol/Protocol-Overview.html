<hr>
<h2>
<a id="layout-defaulttitle-cas---protocol-overviewcategory-protocols" class="anchor" href="#layout-defaulttitle-cas---protocol-overviewcategory-protocols" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>layout: default<br>
title: CAS - Protocol Overview<br>
category: Protocols</h2>
<h1>
<a id="protocols-overview" class="anchor" href="#protocols-overview" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Protocols Overview</h1>
<p>The following protocols are supported and provided by CAS:</p>
<ul>
<li><a href="CAS-Protocol.html">CAS</a></li>
<li><a href="OpenID-Protocol.html">OpenID</a></li>
<li><a href="OAuth-Protocol.html">OAuth</a></li>
<li><a href="OIDC-Protocol.html">OpenID Connect</a></li>
<li><a href="WS-Federation-Protocol.html">WS Federation</a></li>
<li><a href="SAML-Protocol.html">SAML1</a></li>
<li><a href="../installation/Configuring-SAML2-Authentication.html">SAML2</a></li>
<li><a href="REST-Protocol.html">REST Protocol</a></li>
</ul>
<h2>
<a id="design" class="anchor" href="#design" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Design</h2>
<p>CAS presents itself as a multilingual platform supporting protocols such as CAS, SAML2, OAuth2 and OpenID Connect, etc. Support and functionality for each of these protocols continually improves per every iteration and release of the software thanks to excellent community feedback and adoption. While almost all such protocols are similar in nature and intention, they all have their own specific bindings, parameters, payload and security requirements. This section provides a quick introduction on how existing protocols are supported in CAS.</p>
<p>It all starts with something rather trivial: The Bridge.</p>
<h3>
<a id="the-bridge" class="anchor" href="#the-bridge" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The Bridge</h3>
<p>The bridge <em>design pattern</em> is an approach where an intermediary sits between the client and the server, translating requests back and forth. It simply acts as a link between the two sides allowing authentication requests from the client to be translated, massaged and transformed and then routed "invisibly" to CAS and then back.</p>
<p>This is a neat trick because the client does not care how the authentication request is processes once it's submitted. The <em>thing</em> that receives that request, acting as a bridge can do anything required to process that request and ultimately submitting some sort of response back to the client. The bridge also does not care what external authentication system handles and honors that request and how all that processing internally works. All the bridge cares about is, "I routed the request to X. As long as X gives me back the right stuff, I should be fine to resume".</p>
<p>So the bridge for the most part is the "control tower" of the operation. It speaks many languages and protocols, and just like any decent translator, it knows about the quirks and specifics of each language and as such is able to dynamically translate the technical lingo.</p>
<h3>
<a id="supported-protocols" class="anchor" href="#supported-protocols" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Supported Protocols</h3>
<p>If you understand the above strategy, then you would be glad to learn that <em>almost</em> all protocols supported by CAS operate with the same exact intentions. A given CAS deployment is equipped with embedded plugins/bridges/modules that know how to speak SAML2 and CAS, OAuth2 and CAS, or OpenID Connect and CAS or whatever. The right-hand side of that equation is always CAS when you consider, as an example, the following authentication flow with an OAuth2-enabled client application:</p>
<ol>
<li>The CAS deployment has turned on the OAuth2 plugin.</li>
<li>An OAuth2 authorization request is submitted to the relevant CAS endpoint.</li>
<li>The OAuth2 plugin verifies the request and translates it to a CAS authentication request!</li>
<li>The authentication request is routed to the relevant CAS login endpoint.</li>
<li>User authenticates and CAS routes the flow back to the OAuth2 plugin, having issued a service ticket for the plugin.</li>
<li>The OAuth2 plugin attempts to validate that ticket to retrieve the necessary user profile and attributes.</li>
<li>The OAuth2 plugin then proceeds to issue the right OAuth2 response by translating and transforming the profile and validated assertions into what the client application may need.</li>
</ol>
<!-- raw HTML omitted -->
<p>The right-hand side of the flow is always CAS, because the plugin always translates protocol requests into CAS requests. Another way of looking at it is that all protocol plugins and modules are themselves clients of the CAS server! They are issued service tickets and they proceed to validate them just like any other CAS-enabled client. Just like above, to the OAuth2-enabled client all such details are totally transparent and as long as “the right stuff” is produced back to the client, it shall not care.</p>
<p>There are some internal technical and architectural advantages to this approach. Namely:</p>
<p>The core of the CAS authentication engine, flow and components need not be modified at all. After all, we are just integrating yet another client even if it’s embedded directly in CAS itself. Because of that, support for that protocol can be very easily removed, if needed. After all, protocols come and go every day. Finally and just like any other CAS client, all features of the CAS server are readily available and translated to the relevant client removing the need to duplicate and re-create protocol-specific configuration as much as  possible. Things like access strategies, attribute release, username providers, etc.</p>