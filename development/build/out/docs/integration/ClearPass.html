<hr>
<h2>
<a id="layout-defaulttitle-cas---clearpasscategory-authentication" class="anchor" href="#layout-defaulttitle-cas---clearpasscategory-authentication" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>layout: default<br>
title: CAS - ClearPass<br>
category: Authentication</h2>
<p>{% include variables.html %}</p>
<h1>
<a id="clearpass-credential-caching-and-replay" class="anchor" href="#clearpass-credential-caching-and-replay" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ClearPass: Credential Caching and Replay</h1>
<p>To enable single sign-on into some legacy applications it may be necessary to provide them with the actual password.<br>
While such approach inevitably increases security risk, at times this may be a necessary evil in order to integrate<br>
applications with CAS.</p>
<!-- raw HTML omitted -->
<h2>
<a id="overview" class="anchor" href="#overview" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Overview</h2>
<p>CAS is able to issue the credential password directly in the CAS validation response. This previously was handled<br>
via a proxy authentication sequence and obtaining a proxy-granting ticket for the ClearPass service and was necessary<br>
in order to establish trust between the client application and the CAS server. This document describes the configuration<br>
that can be applied in order to receive the credential password as an attribute in the CAS validation response.</p>
<p>In order to successfully establish trust between the<br>
CAS server and the application, private/public key pairs are generated by the client application and then<br>
<strong>the public key</strong> distributed and configured inside CAS. CAS will use the public key to encrypt the credential<br>
password and will issue a new attribute <code>&lt;credential&gt;</code> in the validation response, only if the service is authorized to receive it.</p>
<p>Note that the return of the credential is only carried out by the CAS validation response, provided the client<br>
application issues a request to the <code>/p3/serviceValidate</code> endpoint  (or <code>/p3/proxyValidate</code>). Other means of<br>
returning attributes to CAS, such as SAML1 will <strong>not</strong> support the additional returning of this value.</p>
<p>Also note that CAS by default attempts to encrypt the cached credential in memory via its own pre-generated keys<br>
for signing and encryption. When the attribute is to be released to the application, CAS will internally decode<br>
the credential first and then will attempt to encrypt it again this time using the service's public key credentials.<br>
This behavior can be controlled via <a href="../configuration/Configuration-Properties.html#clearpass">settings</a>.</p>
<!-- raw HTML omitted -->
<h2>
<a id="cache-credential" class="anchor" href="#cache-credential" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Cache Credential</h2>
<p>Enable the caching and capturing of the credential in CAS properties.<br>
To see the relevant list of CAS properties, please <a href="../configuration/Configuration-Properties.html#clearpass">review this guide</a>.</p>
<h2>
<a id="create-keys" class="anchor" href="#create-keys" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Create Keys</h2>
<p>The keypair must be generated by the application itself that wishes to obtain the user credential.<br>
The public key is shared with CAS. The private key is used by the application to decrypt the credential.</p>
<pre lang="bash"><code>openssl genrsa -out private.key 1024
openssl rsa -pubout -in private.key -out public.key -inform PEM -outform DER
openssl pkcs8 -topk8 -inform PER -outform DER -nocrypt -in private.key -out private.p8
</code></pre>
<p>Note that while <code>1024</code> is perfectly fine, you may need to adjust the key size to larger values such<br>
as <code>4096</code> in order to allow CAS to encrypt credentials that are too long in length.</p>
<h2>
<a id="register-public-key" class="anchor" href="#register-public-key" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Register Public Key</h2>
<p>Once you have received the public key from the client application owner, it must be first<br>
registered inside the CAS server's service registry. The service that holds the public key above must also<br>
be authorized to receive the password as an attribute for the given attribute release policy of choice.</p>
<pre lang="json"><code>{
  "@class" : "org.apereo.cas.services.RegexRegisteredService",
  "serviceId" : "^https://.+",
  "attributeReleasePolicy" : {
    "@class" : "org.apereo.cas.services.ReturnAllowedAttributeReleasePolicy",
    "authorizedToReleaseCredentialPassword" : true
  },
  "publicKey" : {
    "@class" : "org.apereo.cas.services.RegisteredServicePublicKeyImpl",
    "location" : "classpath:public.key",
    "algorithm" : "RSA"
  }
}
</code></pre>
<h2>
<a id="decrypt-the-password" class="anchor" href="#decrypt-the-password" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Decrypt the Password</h2>
<p>Once the client application has received the <code>credential</code> attribute in the CAS validation response, it can decrypt<br>
it via its own private key. Since the attribute is base64 encoded by default, it needs to be decoded first before<br>
decryption can occur. Here's a sample code snippet:</p>
<pre lang="java"><code>final Map&lt;?, ?&gt; attributes = ...
final String encodedPsw = (String) attributes.get("credential");

/* Use the private.key file generated above. */
final PrivateKey privateKey = ...
final Cipher cipher = Cipher.getInstance(privateKey.getAlgorithm());
final byte[] cred64 = decodeBase64(encodedPsw);
cipher.init(Cipher.DECRYPT_MODE, privateKey);
final byte[] cipherData = cipher.doFinal(cred64);
return new String(cipherData);
</code></pre>