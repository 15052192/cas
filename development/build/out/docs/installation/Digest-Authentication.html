<hr>
<h2>
<a id="layout-defaulttitle-cas---digest-authenticationcategory-authentication" class="anchor" href="#layout-defaulttitle-cas---digest-authenticationcategory-authentication" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>layout: default<br>
title: CAS - Digest Authentication<br>
category: Authentication</h2>
<p>{% include variables.html %}</p>
<h1>
<a id="digest-authentication" class="anchor" href="#digest-authentication" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Digest Authentication</h1>
<p>Digest authentication is one of the agreed-upon methods CAS can use to negotiate credentials with a user's<br>
web browser. This can be used to confirm the identity of a user before sending sensitive information.<br>
It applies a hash function to the username and password before sending them over the network.<br>
Technically, digest authentication is an application of MD5 cryptographic<br>
hashing with usage of nonce values to prevent replay attacks. It uses the HTTP protocol.</p>
<p>Support is enabled by including the following dependency in the WAR overlay:</p>
<p>{% include casmodule.html group="org.apereo.cas" module="cas-server-support-digest-authentication" %}</p>
<p>For additional information on how digest authentication works,<br>
please <a href="https://en.wikipedia.org/wiki/Digest_access_authentication">review this guide</a>.</p>
<h2>
<a id="configuration" class="anchor" href="#configuration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Configuration</h2>
<p>To see the relevant list of CAS properties, please <a href="../configuration/Configuration-Properties.html#digest-authentication">review this guide</a>.</p>
<h2>
<a id="credential-management" class="anchor" href="#credential-management" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Credential Management</h2>
<p>By default, CAS attempts to cross-check computed hash values against what the client reports in the authentication request.<br>
In order for this to succeed, CAS will need access to the data store where MD5 representations of credentials are kept. The store<br>
needs to keep the hash value at a minimum of course.</p>
<p>By default, CAS uses its properties file to house the hashed credentials. Real production-level deployments<br>
of this module will need to provide their own data store that provides a collection of hashed values as authenticating accounts.</p>
<h2>
<a id="client-requests" class="anchor" href="#client-requests" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Client Requests</h2>
<p>The following snippets demonstrate how a given Java client may use CAS digest authentication,<br>
via Apache's HttpClient library:</p>
<pre lang="java"><code>final HttpHost target = new HttpHost("localhost", 8080, "http");

final CredentialsProvider credsProvider = new BasicCredentialsProvider();
credsProvider.setCredentials(
        new AuthScope(target.getHostName(), target.getPort()),
        new UsernamePasswordCredentials("casuser", "Mellon"));

final CloseableHttpClient httpclient = HttpClients.custom()
        .setDefaultCredentialsProvider(credsProvider)
        .build();

try {
    HttpGet httpget = new HttpGet("http://localhost:8080/cas/login");

    // Create AuthCache instance
    final AuthCache authCache = new BasicAuthCache();

    // Generate DIGEST scheme object, initialize it and add it to the local auth cache
    final DigestScheme digestAuth = new DigestScheme();
    digestAuth.overrideParamter("realm", "CAS");
    authCache.put(target, digestAuth);

    // Add AuthCache to the execution context
    final HttpClientContext localContext = HttpClientContext.create();
    localContext.setAuthCache(authCache);

    System.out.println("Executing request " + httpget.getRequestLine() + " to target " + target);
    try (CloseableHttpResponse response = httpclient.execute(target, httpget, localContext)) {
        System.out.println(response.getStatusLine());
        System.out.println(EntityUtils.toString(response.getEntity()));
    }
} finally {
    httpclient.close();
}
</code></pre>