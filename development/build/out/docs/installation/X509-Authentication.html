<hr>
<h2>
<a id="layout-defaulttitle-cas---x509-authenticationcategory-authentication" class="anchor" href="#layout-defaulttitle-cas---x509-authenticationcategory-authentication" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>layout: default<br>
title: CAS - X.509 Authentication<br>
category: Authentication</h2>
<h1>
<a id="x509-authentication" class="anchor" href="#x509-authentication" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>X.509 Authentication</h1>
<p>CAS X.509 authentication components provide a mechanism to authenticate users who present client certificates during<br>
the SSL/TLS handshake process. The X.509 components require configuration outside the CAS application since the<br>
SSL handshake happens outside the servlet layer where the CAS application resides. There is no particular requirement<br>
on deployment architecture (i.e. Apache reverse proxy, load balancer SSL termination) other than any client<br>
certificate presented in the SSL handshake be accessible to the servlet container as a request attribute named<br>
<code>javax.servlet.request.X509Certificate</code>. This happens naturally for configurations that terminate SSL connections<br>
directly at the servlet container and when using <code>Apache/mod_jk</code>; for other architectures it may be necessary to do<br>
additional work.</p>
<p>CAS can be configured to extract an X509 certificate from a header created by a proxy running in front of CAS.</p>
<h2>
<a id="overview" class="anchor" href="#overview" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Overview</h2>
<p>Certificates are exchanged as part of the SSL (also called TLS) initialization that occurs when any browser connects to an <code>https</code> website.<br>
A certain number of public CA certificates are preinstalled in each browser. It is assumed that:</p>
<ul>
<li>Your organization is already able to generate and distribute certificates that a user can install in their browser</li>
<li>Somewhere in that certificate there is a field that contains the Principal name or can be<br>
easily mapped to the Principal name that CAS can use.</li>
</ul>
<p>The remaining problem is to make sure that the browsers, servers and Java are all prepared to support<br>
these institutional certificates and, ideally,<br>
that these institutional certificates will be the only ones exchanged when a browser connects to CAS.</p>
<h2>
<a id="flow" class="anchor" href="#flow" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Flow</h2>
<p>When a browser connects to CAS over an https: URL, the server identifies itself by sending its own certificate. The<br>
browser must already have installed a certificate identifying and trusting the CA that issued the CAS Server certificate.<br>
If the browser is not already prepared to trust the CAS server, then an error message pops up saying the server is not trusted.</p>
<p>After the Server sends the certificate that identifies itself, it then can then send a list of names of Certificate<br>
Authorities from which it is willing to accept certificates. Ideally, this list will include only one name; the name<br>
of the internal institutional CA that issues internal intranet-only certificates that internally contain a field with the CAS Principal name.</p>
<p>A user may install any number of certificates into the browser from any number of CA's. If only one of these certificates<br>
comes from a CA named in the list of acceptable CA's sent by the server, then most browsers will automatically send that<br>
one certificate without asking, and some can be configured in to not ask when there is only one possible choice. This<br>
presents a user experience where CAS becomes transparent to the user after some initial setup and the login happens<br>
automatically. However, if the server hosting CAS sends more than one CA name in the list and that matches more than<br>
one certificate on the browser, then the user will get prompted to choose a Certificate from the list. A user interaction<br>
defeats much of the purpose of certificates in CAS.</p>
<p>Note that CAS does not control this exchange. It is handled by the underlying server. You may not have the control to<br>
require the server to vend only one CA name when a browser visits CAS. So if you want to use X.509 certificates in CAS,<br>
you should consider this requirement when choosing the hosting environment. The ideal situation is to select a server<br>
that can identify itself with a public certificate issued by something like VeriSign or InCommon but then require the<br>
client certificate only be issued by the internal corporate/campus authority.</p>
<p>When CAS gets control, a user certificate may have been presented by the browser and be<br>
stored in the request. The CAS X.509 authentication machinery examines that certificate<br>
and verifies that it was issued by the trusted institutional authority. Then CAS searches<br>
through the fields of the certificate to identify one or more fields that can<br>
be turned into the principal identifier that the applications expect.</p>
<p>While an institution can have one certificate authority that issues certificates to employees, clients,<br>
machines, services, and devices, it is more common for the institution to have a single "root" certificate<br>
authority that in its entire existence only issues a handful of certificates. Each of<br>
these certificates identifies a secondary Certificate Authority<br>
that issues a particular category of certificates (to students, staff, servers, etc.). It is possible to<br>
configure CAS to trust the root Authority and, implicitly, all the secondary authorities<br>
that it creates. This, however, makes CAS only as secure as the<br>
least reliable secondary Certificate Authority created by the institution. At some point in the future,<br>
some manager will buy a product that requires a new class of certificates. He will ask to create a<br>
Certificate Authority that vends these certificates to the machines running this new product. He<br>
will then turn administration of this mess over to a junior<br>
programmer or consultant. If CAS trusts any certificate issued by any Authority created by the root,<br>
it will trust a fraudulent certificate forged by someone who has acquired control of what was intended<br>
to be a special purpose, isolated CA. Therefore, it is better to configure CAS to only accept<br>
certificates from the one secondary CA specifically expected to issue credentials to<br>
individuals, instead of trusting the institutional root CA.</p>
<h2>
<a id="configuration" class="anchor" href="#configuration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Configuration</h2>
<p>X.509 support is enabled by including the following dependency in the WAR overlay:</p>
<p>{% include casmodule.html group="org.apereo.cas" module="cas-server-support-x509-webflow" %}</p>
<p>The X.509 handler technically performs additional checks <em>after</em> the real SSL client authentication process performed<br>
by the Web server terminating the SSL connection. Since an SSL peer may be configured to accept a wide range of<br>
certificates, the CAS X.509 handler provides a number of properties that place additional restrictions on<br>
acceptable client certificates.</p>
<p>To see the relevant list of CAS properties, please <a href="../configuration/Configuration-Properties.html#x509-authentication">review this guide</a>.</p>
<h2>
<a id="web-server-configuration" class="anchor" href="#web-server-configuration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Web Server Configuration</h2>
<p>X.509 configuration requires substantial configuration outside the CAS Web application. The configuration of Web<br>
server SSL components varies dramatically with software and is outside the scope of this document. We offer some<br>
general advice for SSL configuration:</p>
<ul>
<li>Configuring SSL components for optional client certificate behavior generally provides better user experience.<br>
Requiring client certificates prevents SSL negotiation in cases where the certificate is not present, which prevents<br>
user-friendly server-side error messages.</li>
<li>Accept certificates only from trusted issuers, generally those within your PKI.</li>
<li>Specify all certificates in the certificate chain(s) of allowed issuers.</li>
</ul>
<h3>
<a id="embedded-web-server" class="anchor" href="#embedded-web-server" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Embedded Web Server</h3>
<p>While instructions here generally apply to an external server deployment such as Apache Tomcat, that<br>
is not a hard requirement. X.509 authentication can be achieved with an embedded Apache Tomcat<br>
container that ships with CAS and can be potentially simplify the configuration and automation steps<br>
quite a bit, depending on use case and behavior. The configuration of certificate and trust stores<br>
as well as behavior and enforcement of client authentication can also be managed directly by CAS.</p>
<p>To see the relevant list of CAS properties, please <a href="../configuration/Configuration-Properties.html#embedded-container">review this guide</a>.</p>
<h4>
<a id="optional-mixed-authentication" class="anchor" href="#optional-mixed-authentication" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Optional (Mixed) Authentication</h4>
<p>When using an <a href="Configuring-Servlet-Container.html">embedded Apache Tomcat container</a>, it may be<br>
required to allow the user to select either X.509 authentication or the usual CAS login flow without first being prompted.<br>
In this scenario, the user is allowed the option to select a login flow via X.509 at which time the browser would present<br>
a dialog prompt asking for a certificate selection and then passing it onto CAS to proceed.</p>
<p>This behavior is achieved by exposing a dedicated port for the embedded Apache Tomcat container that<br>
may forcefully require X.509 authentication for login and access. Doing so should automatically allow for an extra<br>
login option in the user interface to trigger the browser for X.509.</p>
<p>To see the relevant list of CAS properties,<br>
please <a href="../configuration/Configuration-Properties.html#x509-authentication">review this guide</a>.</p>
<h3>
<a id="external-apache-tomcat" class="anchor" href="#external-apache-tomcat" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>External Apache Tomcat</h3>
<p>Anything said here extends the <a href="https://tomcat.apache.org/tomcat-9.0-doc/ssl-howto.html">Apache Tomcat reference for SSL</a>.</p>
<p>The Tomcat server is configured in <code>$CATALINA_HOME/conf/server.xml</code> with one or more <code>&lt;Connector&gt;</code> elements. Each of these elements<br>
defines one port number on which Tomcat will listen for requests. Connectors that support SSL are configured with one or two files<br>
that represent a collection of X.509 certificates.</p>
<ul>
<li>
<p>The <code>keystoreFile</code> is a collection of X.509 certificates one of which Tomcat will use to identify itself to<br>
browsers. This certificate contains the DNS name of the server on which Tomcat is running which the HTTP client<br>
will have used as the server name part of the URL. It is possible to use a file that contains multiple<br>
certificates (in which case Tomcat will use the certificate stored under the alias "Tomcat" or, if that<br>
is not found, will use the first certificate it finds that also has an associated private key). However,<br>
to assure that no mistakes are made it is sensible practice to use a file that has only the one host<br>
certificate, plus of course its private key and chain of parent Certificate Authorities.</p>
</li>
<li>
<p>The <code>truststoreFile</code> is a collection of X.509 certificates representing Certificate Authorities from which<br>
Tomcat is willing to accept user certificates. Since the <code>keystoreFile</code> contains the CA that issued the certificate identifying the server,<br>
the <code>truststoreFile</code> and <code>keystoreFile</code> could be the same in a CAS configuration where the URL (actually the port) that uses X.509 authentication is<br>
not the well know widely recognized URL for interactive (userid/password form) login, and therefore the only CA<br>
that it trusts is the institutional internal CA.</p>
</li>
</ul>
<p>One strategy if you are planning to support both X.509 and userid/password validation through the same port is to put a<br>
public (VeriSign, Thawte) certificate for this server in the <code>keystoreFile</code>, but then put only the institutional<br>
internal CA certificate in the <code>truststoreFile</code>. Logically and in all the documentation,<br>
the Certificate Authority that issues the certificate to the<br>
server which the browser trusts is completely and logically independent of the Certificate Authority that issues the<br>
certificate to the user which the server then trusts. Java keeps them separate, Tomcat keeps them separate, and browsers<br>
should not be confused if, during SSL negotiation, the server requests a user certificate from a CA other than the<br>
one that issued the server's own identifying certificate. In this configuration, the Server issues a public certificate<br>
every browser will accept and the browser is strongly urged to send only a private institutional<br>
certificate that can be mapped to a Principal name.</p>
<!-- raw HTML omitted -->
<p>The configured connector will look something like:</p>
<pre lang="xml"><code>&lt;!-- Define a SSL HTTP/1.1 Connector on port 443 --&gt;
&lt;!-- if you do not specify a truststoreFile, then the default java "cacerts" truststore will be used--&gt;
&lt;Connector port="443"
    maxHttpHeaderSize="8192"
    maxThreads="150"
    minSpareThreads="25"
    maxSpareThreads="75"
    enableLookups="false"
    disableUploadTimeout="true"
    acceptCount="100"
    scheme="https"
    secure="true"
    clientAuth="want"
    sslProtocol="TLS"
    keystoreFile="/path/to/keystore.jks"
    keystorePass="secret"
    truststoreFile="/path/to/myTrustStore.jks"
    truststorePass="secret" /&gt;
</code></pre>
<p>The <code>clientAuth="want"</code> tells Tomcat to request that the browser provide a user certificate if one is available. If<br>
you want to force the use of user certificates, replace <code>"want"</code> with <code>"true"</code>.<br>
If you specify <code>"want"</code> and the browser does not have a certificate, then CAS may forward the request to the login form.</p>
<p>The keystore can be in <code>JKS</code> or <code>PKCS12</code> format when using Tomcat. When using both <code>PKCS12</code> and JKS keystore types<br>
then you should specify the type of each keystore by using the <code>keystoreType</code> and <code>truststoreType</code> attributes.</p>
<p>You may import the certificate of the institutional Certificate Authority (the one that issues User certificates) using the command:</p>
<pre lang="bash"><code># Create a blank keystore to start from scratch if needed
# keytool -genkey -keyalg RSA -alias "selfsigned" -keystore myTrustStore.jks -storepass "secret" -validity 360
# keytool -delete -alias "selfsigned" -keystore myTrustStore.jks

keytool -import -alias myAlias -keystore /path/to/myTrustStore.jks -file certificateForInstitutionalCA.crt
</code></pre>